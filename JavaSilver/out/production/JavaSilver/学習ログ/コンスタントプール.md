# コンスタントプールを使った問題
```
public class Main {

    public static void main(String[] args) {
               String a = "sample";
               String b = "sample";
               System.out.print(a == b);
               System.out.print(", ");
              System.out.println(a.equals(b));
              //true, true
              //a と b は、物理的に同じメモリ上のオブジェクトを指している
              //だから、住所を比較する == でも true になる
    }
}

```

## そもそもコンスタントプールが使われる条件は？
コンスタントプールが使われるのは、以下の 「コンパイルする時点で中身が確定しているもの（定数）」 だけ
`"ABC" のようなリテラル（直書き）String s = "sample";`
`"A" + "B" のような定数同士の結合`

### 前半の a == b について
本来、== は「メモリ上の場所（アドレス）」が同じかを比較するもの
通常、変数を2つ作れば場所は別々になるはず.
Javaはメモリを節約するために**「文字列コンスタントプール」**という特別な領域を持つ
```
3行目: String a = "sample";
Javaはコンスタントプールの中を覗きます
プールの中に "sample" という実体を作成し、変数 a にその住所（アドレス）を持たせます。

4行目: String b = "sample";
Javaは再びコンスタントプールの中を覗きます
この時javaはaにsampleがある方ら「じゃあ新しいのを作らずに、これを使い回そう」と判断
変数 b には、a と全く同じ（アドレス）が渡される
```


### もし new を使っていたら?
```
String a = new String("sample");
String b = new String("sample");
```
この場合a.equals(b) は true（中身は同じだから）

a == b は false（強制的に別の場所に作らせたから）


## コンスタントプールの使う判断
コンスタントプールが「使われない」ケース
たとえ new を書いていなくても、変数が絡んだ連結を行うと、実行時に計算が行われるため、ヒープ領域に新しいオブジェクトが作ラル
```
public class PoolTrap {
    public static void main(String[] args) {
        String str1 = "sample";
        String str2 = "sam" + "ple";  // ① 定数同士
        
        String part = "sam";
        String str3 = part + "ple";   // ② 変数 + 定数

        // ① 定数同士の結合は、コンパイル時に "sample" になるのでプールを使う
        System.out.println(str1 == str2); // true

        // ② 変数が絡むと、実行時に計算されるので新しいオブジェクトになる！
        System.out.println(str1 == str3); // false (⭐️)
    }
}

str2 の場合:コンパイラは賢いので、「"sam" と "ple" は両方とも固定値だね。じゃあ最初から "sample" として扱おう」と最適化

str3 の場合:part は変数
Javaは「実行してみないと part の中身が変わるかもしれない」と考える
```

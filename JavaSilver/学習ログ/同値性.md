# 同値性
## [b2af8231925b32dc4b5e43f77fbbba8fd847fc3a]()
このコードの回答は何になるか？
## まず考えるべきこと
- new キーワードが出てきたら、メモリの「ヒープ領域」に新しいオブジェクト（インスタンス）が作られることをイメージ
- `Sample a = new Sample(10, "a");変数 a は Address:01`
- `Sample b = new Sample(10, "b");変数 a と b は、中身の数値は似ていますが、全く別の物体`
- そして、変数 a と b は、そのオブジェクアドレスを作るだけ

## 使うメソッド: equals()
「オブジェクトが持っている**中身（値）**が同じか？

## なぜオーバーライドが必要か？
全てのクラスの親である Object クラスにも equals メソッドがあるけど実は初期状態では == と全く同じ動き（同一性のチェック） をするように作られている
だからこそ、Sample クラスのように「中身を比較したい」場合は、プログラマが自分で equals を**上書き（オーバーライド）**して、「何をもって『等しい』とするか」を再定義する必要がある.

ちなみに
equalsメソッドをオーバーライドしていないクラスでは、Objectクラスのequalsが継承される
これは内部で「==」を使用しており、参照先（アドレス）が異なる別々のオブジェクトはfalseと判定される
つまりオーバライドされていなかったら「同一性」の確認となってしまう
## 下のコードの出力値について
```
String s1 = new String("sample");
String s2 = new String("sample");

System.out.println((s1 == s2) + ", " + s1.equals(s2));
//false, true
```
- newを使用すると必ず新しいメモリ領域が確保されるため、==（同一性）はfalse
- 一方、Stringクラスはequalsをオーバーライドして「文字列の中身」を比較するように作られているため、equals（同値性）はtrue

## 同一性と同値性の違い
同一性:「完全に同じモノか？」 を確認
メモリ上の**場所（アドレス）**が一致しているかどうか

同値性 :「中身が同じか？」 を確認
場所は違っても、持っている**データ（値）**がルール通りに一致しているか

```
// 1. 新しいスマホを2台買いました（機種も設定も全く同じ）
Phone p1 = new Phone("iPhone 15");
Phone p2 = new Phone("iPhone 15");

// 【同一性】== (場所の比較)
// p1とp2は「別のモノ」なので、場所は違います
System.out.println(p1 == p2);       // false

// 【同値性】equals (中身の比較)
// ※Phoneクラスでequalsを正しく作っていれば
// 「機種名が同じならOK」として true になります
System.out.println(p1.equals(p2));  // true
```



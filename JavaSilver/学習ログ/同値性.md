# 同値性
## b2af8231925b32dc4b5e43f77fbbba8fd847fc3a
このコードの回答は何になるか？
## まず考えるべきこと
- new キーワードが出てきたら、メモリの「ヒープ領域」に新しいオブジェクト（インスタンス）が作られることをイメージ
- `Sample a = new Sample(10, "a");変数 a は Address:01`
- `Sample b = new Sample(10, "b");変数 a と b は、中身の数値は似ていますが、全く別の物体`
- そして、変数 a と b は、そのオブジェクアドレスを作るだけ

## 使うメソッド: equals()
「オブジェクトが持っている**中身（値）**が同じか？

## なぜオーバーライドが必要か？
全てのクラスの親である Object クラスにも equals メソッドがあるけど実は初期状態では == と全く同じ動き（同一性のチェック） をするように作られている
だからこそ、Sample クラスのように「中身を比較したい」場合は、プログラマが自分で equals を**上書き（オーバーライド）**して、「何をもって『等しい』とするか」を再定義する必要がある

ちなみに
equalsメソッドをオーバーライドしていないクラスでは、Objectクラスのequalsが継承される
これは内部で「==」を使用しており、参照先（アドレス）が異なる別々のオブジェクトはfalseと判定される

## 下のコードの出力値について
```
String s1 = new String("sample");
String s2 = new String("sample");

System.out.println((s1 == s2) + ", " + s1.equals(s2));
//false, true
```
- newを使用すると必ず新しいメモリ領域が確保されるため、==（同一性）はfalse
- 一方、Stringクラスはequalsをオーバーライドして「文字列の中身」を比較するように作られているため、equals（同値性）はtrue
